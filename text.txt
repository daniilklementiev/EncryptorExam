0. Системное программирование. WinAPI


Системное программирование - изучение возможностей системы 
WinAPI - это интерфейс взаимодействия приложений с ОС, как с программой. Дословно - Windows Application-Program Interface.

Интерфейс - способ взаимодействия. 
Программа - информационный центр.
Приложение - часть системы, взаимодействующая с программой.
Кодировка
Кодировки решают проблему отображения текстовой информации. 
Предпосылки создания и развитие Юникода
В Windows существует две кодировки:
ANSI           (A)
Unicode  (UTF-8, UTF-16, UTF-32)   (W - wchar_t) - рекомендовано использовать именно эту кодировку, т.к. она новее и обширнее
Также почти все функции доступны в двух вариантах
CreateWindowW()
CreateWindowA()
Unicode 
Unicode - не кодировка, а правила кодировки. 
Unicode включает в себя другие кодировки, например, UTF-8. Рекомендуется использовать W-версии, не использовать автоподстановку (W = Unicode)
Рекомендуется  не использовать, но в случае использования это нужно обосновать.

CreateWindowW - параметры будут интерпретироваться, как wchar  
Окно
Окно - графический интерфейс программы, с его помощью можно отслеживать как работает программа и управлять ей
	в windows это не только окно которое можно свернуть, закрыть, но и кнопки, поля с текстом (static) и поля для ввода (edit)
 

	Структура оконного приложения:
	
	wWinMain(
	_In_ HINSTANCE hInstance, // дескриптор программы (номер(ID) процесса в ОС)
	_In_opt_ HINSTANCE hPrevInstance, // дескриптор пред. запуска (если есть)
	_In_ LPWSTR lpCmdLine, // агрументы командной строки
	_In_ int nCmdShow // начальный режим отображения
	)
	
Регистация класса окна
Создание окна
Запуск цикла сообщений
	
	
	RegisterClassExW(// регстрация класса окна. В ООП синоним описания класса
	&wcex //структура класс окна
	);
	
	
	WNDCLASSEXW wcex;
	
	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.lpfnWndProc = WndProc;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.lpszClassName = szWindowClass;
	

	Оконная процедура WndProc, тело которой большой switch анализирующий сообщения
	

Обьект окна
	
	CreateWindowW( // hWnd = new WinСlass
	szWindowClass, // имя класса
	szTitle, // заголовок окна (надпись слева-верха)
	WS_OVERLAPPEDWINDOW,
	CW_USEDEFAULT,
	0,
	200, // ширина окна
	200, // высота окна
	nullptr,
	nullptr,
	hInstance,
	nullptr);
Событие
К событиям пользователя относятся все способы взаимодействия с программой: 
щелчки мыши, клавиши, жесты с сенсорным экраном и т. д.

	События операционной системы включают все «вне» программы, которая может повлиять на работу программы. например, пользователь может подключить новое аппаратное устройство или Windows может перейти в режим пониженного энергопотребления (спящий или спящий режим).

	Эти события могут возникать в любое время, пока программа выполняется, в почти в любом порядке.
	Как структурировать программу, поток выполнения которой нельзя спрогнозировать заранее?

	Чтобы решить эту проблему, Windows использует модель передачи сообщений. 
	Операционная система взаимодействует с окном приложения, передавая ему сообщения. 
Сообщение
CPU (Central Processor Unit) - АЛУ (арифметико-логическое устройство) - не умеет взаимодействовать с периферией

Сообщение - это числовой код, обозначающий определенное событие. 
Например, если пользователь нажимает левую кнопку мыши, окно получает сообщение, в котором содержится следующий код сообщения.

Прерывание (Interruption) - переключение процессора на обработку сигнала от периферийного устройства - происшествие железного уровня

Результат обработки прерывания превращается в сообщение (Message), посылаемое в операционную систему. Происшествие системного уровня.  Сообщение сопровождается деталями, сохраненными в процессе обработки прерывания (как структура данных) (но не все сообщения являются результатом прерывания!!!) ; ~организация, процесс взаимодействия между элементами системы; структура MSG - набор данных; механизм взаимодействия между окнами; главный плюс - легко расширять систему

Приложения в ОС работают по принципу ожидания сообщений - находятся в бесконечном цикле ожидания-перевода-обработки системных сообщений

Сообщение сопровождается данными, которые хранятся в структуре (разные виды сообщений формируют разные структуры)

Виды сообщений: 

 Жизненный цикл 
WM_PAINT:
WM_DESTROY
default
 Пользовательский интерфейс 
WM_COMMAND (int wmId = LOWORD(wParam);)
Notifications (int notifid = HIWORD(wParam);)
 Системные (сообщения периферии - клавиатура, мышь и т.д.)

Уведомления (Notifications) 

Уведомления - это разновидность сообщений, посылаемых дочерними элементами родительскому окну. 
Уведомления приходят как сообщения WM_COMMAND, код уведомления передается в старшем слове (HIWORD) wParam
Например, Combobox посылает уведомление CBN_SELCHANGE 
(Selection Changed - изменен выбор: мышью, колесом, стрелками)

Само уведомление не содержит данных о выборе, для их получения нужно послать сообщение(я) Combobox'у 

CB_GETCURSEL - Get Current Selection Index (индекс выбранного пункта)
CB_GETLBTEXT - текст строки (wParam = индекс строки)
Системная очередь сообщений
Пока одно сообщение не обработано, к другому не приступает (??)
Обработка сообщений
Сообщение, которое не успевает выполниться, попадает в очередь. Сама очередь ограничена, т.е. она может переполниться. 
Очередь сообщении приложения 
Приложение может создавать сообщения для использования в собственных окнах или для взаимодействия с Windows в других процессах.
	Если приложение создает собственные сообщения, процедура окна, принимающая их, должна интерпретировать сообщения и обеспечить соответствующую обработку.
Типы диалогов
Модальный диалог - блокирует приложение до тех пор, пока не завершится или пока не вызовется его завершающая функция
Немодальный диалог - не блокирует приложение, требует модификации оконной процедуры
Синхронные сообщения
Синхронными сообщениями называются сообщения, которые Windows помещает в очередь сообщений программы, и которые извлекаются и диспетчеризуются в цикле обработки сообщений.
Асинхронные сообщения
Асинхронные сообщения - сообщения которые не отправляются в очередь, а напрямую в оконную процедуру
	В результате оконная процедура получает все предназначенные для окна сообщения, как синхронные, так и асинхронные.
	Например: если сообщение отправляется с помощью функции SendMessage, то оно является асинхронным
Процесс
Процесс (в терминах системного программирования) - запуск и работа приложения. (термин означающий однозадачную систему между которыми переключается многозадачная ОС)

Процесс - исполнение исполняемого кода, запуск исполняемого кода, новый запуск exe-файла: 
потоки создаются внутри процесса процессы могут также запускаться и останавливаться другими процессами (потоками).
 Потоки
https://habr.com/ru/post/279653/
Системные потоки - части кода выполняющиеся параллельно (асинхронно) 
	Идея многопоточности возникла с достижением предела физического ускорения работы пк:
Частота (длина волны меньше мат.платы)
Нагрев
Фактор размера

Традиционно поток стартует в функции (процедуре)
Окончание функции (return) → завершает поток

 Многозадачность
Многозадачность - свойство выполнять несколько процессов (задач) одновременно (параллельно), 
	также ОС может "переключатся" между процессами создавая эффект псевдомногозадачность


 Многопоточность
	Многопоточность - свойство выполнять несколько процедур (процедур так как в потоках обычно исполняется процедура) в рамках одного процесса
	При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов.


статья 


 Синхронизация(примитивы синхронизации) -  о каждом надо говорить 

Атомарность операции - эффект транзакции - "все или ничего"
                                              - выполнение операции присваивания (вычисление правой части перенос в левую часть) как неразрывного процесса.
 
	  x = x + 1
	а) извлекается значение x (переносится из памяти в проц.)
	б) добавляется 1 (x+1 еще находится в проц.)
	в) из процессора данные переносятся в память "х"
	
	проблема между а и в может "вклиниться" другой поток
	Атомарность - неделимость, неразрывность а-б-в
	
	Решения: 
	сигнальные объекты + состояние ожидания


	mutex - сокращение от mutual exclusion (взаимное исключение) 
	mutex - сигнальный объект позволяющий ограничить (синхронизировать) одновременное использование ресурсов

	Критическая секция это область памяти которая предотвращает одновременный совместный доступ разных потоков к одному ресурсу
	в отличии от мьютекса критическая секция доступна одному процессу она не может работать в нескольких процессах.
	У неё нет имени, только адрес, который определен в рамках одного процесса.

	Семафор - объект позволяющий ограничить кол во потоков которые выполняются одновременно,
	так как большое кол-во потоков может снизить производительность (потоковое голодание), чтобы это избежать существует семафор

 DLL
		﻿DLL - Dynamic Link Library
Библиотека - набор функций в виде отдельного файла/модуля
Компоновка (link) подключение библиотеки - получение доступа к ее функциям
	
	Статическая компоновка - подключение функций в исходный код
	Динамическая компоновка в исполняемый код (во время выполнения)
	
	Статическая 
код более самостоятельный не нужны файлы для работы
код больше за счет включения доп функций, причем оптом - всю библиотеку, независимо от кол-ва использованных функций
== хорошо для готовой продукции которая исполняется на разных ПК
	
	Динамическая 
код зависит от доп файлов при копирования/переносе их нужно не забыть
код вызывает из другого файла, сам при этом короче
== хорошо для распределенных программ (с приложениями/обновлениями)
		+ немного лучше защита авторских прав - сложнее переделать
		+ совместимость между языками
	
		Для иллюстрации работы с dll необходимы 2 проекта:
		-- dll продуктом будет dll
		-- winapi/console - сюда нужно скопировать или указать 
		   путь к dll файлу созданному в проекте 1
	
		Экспортируемые функции оформляются в блоке 
		extern "C"{ }
		в прототипе функции используется декларация 
		__decspec(dllexport)
	   	 главная функция (DllMain) возвращает 1 (TRUE)
	
	
		Библиотека подключается командой 
			HANDLE dll = LoadLibraryW(L"dll.dll");
			после чего нужно проверить на NULL
Для запуска функции извлекается указатель на нее с этой целью удобнее определить тип нового функционального указателя
	
	
			typedef long (*sqr_type)(long);
			sqr_type sqr_fun;
		Указатель из модуля (библиотеки) извлекается функцией.
		После извлечения его нужно типизировать (sqr_fun)

Hooks (Хуки)

	Прием / способ организации кода позволяющий вставлять свои процедуры в существующие, образуя цепочку вызовов. Позже, подобный подход получил название MiddleWare
	
	Прерывание клавиатуры -> BIOS (адрес обработчика) -X-> обработчик
										^					                                                                                      ^
								заменяем на наш адрес		                                                                                                               |
								(старый сохраняем)			  								|
										|					  							|
						наш код	--- переход по старому адресу
	
			петля на схеме (англ. Hook) дала название этому приему
	
	OC позволяет устанавливать (и отменять) хуки для ряда прерываний и сообщений.
	WinAPI содержит предопределенные константы для работы с наиболее
	популярными из них.
	
	
	    kbHOOK = SetWindowsHookExW(  дескриптор хука, нужен для его включения
		WH_KEYBOARD, тип хука - предопределенная константа
		KbHookProc, адрес процедуры, которая встраивается в петлю
		(HINSTANCE)NULL, отсчет адреса
		GetCurrentThreadId()); номер потока
	
		return CallNextHookEx(kbHOOK,nCode,wParam,lParam); - замыкание петли - вызов следующего хука (предыдущий адрес)
	

	--------------------------------
	
		хуки низкого уровня (LL - LowLevel)
	
		kbLL = SetWindowsHookExW(WH_KEYBOARD_LL,
		KbHookProcLL,
		GetModuleHandle(NULL), // дескриптор модуля (DLL / EXE)
		0);
	
	--------------------------
	
	Мышь
	
	typedef struct tagMOUSEHOOKSTRUCT {
	  POINT     pt;
	  HWND      hwnd;
	  UINT      wHitTestCode;
	  ULONG_PTR dwExtraInfo;
	} MOUSEHOOKSTRUCT, *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;
	
	
	typedef struct tagPOINT {
	  LONG x;
	  LONG y;
	} POINT, *PPOINT;


